<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        h1 { text-align: center; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        
        /* Auth Section */
        .auth-section {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            margin: 0 auto 30px;
        }
        .auth-section h2 { margin-bottom: 20px; text-align: center; }
        .auth-tabs { display: flex; margin-bottom: 20px; }
        .auth-tab {
            flex: 1; padding: 10px; text-align: center;
            background: rgba(255,255,255,0.1); cursor: pointer;
            border: none; color: #fff; font-size: 1em;
            transition: all 0.2s;
        }
        .auth-tab:first-child { border-radius: 8px 0 0 8px; }
        .auth-tab:last-child { border-radius: 0 8px 8px 0; }
        .auth-tab.active { background: rgba(102, 126, 234, 0.6); }
        .auth-form { display: none; }
        .auth-form.active { display: block; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; color: #ccc; }
        .form-group input {
            width: 100%; padding: 12px; border: none;
            border-radius: 8px; font-size: 1em;
            background: rgba(255,255,255,0.9); color: #333;
        }
        .btn {
            width: 100%; padding: 12px; border: none;
            border-radius: 8px; font-size: 1em; cursor: pointer;
            font-weight: bold; transition: all 0.2s;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-secondary { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; }
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        /* Lobby Section */
        .lobby-section { display: none; }
        .lobby-section.active { display: block; }
        .user-info {
            background: rgba(255,255,255,0.1);
            border-radius: 8px; padding: 15px;
            margin-bottom: 20px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .games-container {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px; margin-bottom: 20px;
        }
        .game-card {
            background: rgba(255,255,255,0.1);
            border-radius: 12px; padding: 20px;
            transition: all 0.2s;
        }
        .game-card:hover { background: rgba(255,255,255,0.15); transform: translateY(-2px); }
        .game-card h3 { margin-bottom: 10px; color: #fff; }
        .game-card .players { color: #ccc; margin-bottom: 15px; font-size: 0.9em; }
        .game-card .actions { display: flex; gap: 10px; }
        .game-card .btn { width: auto; padding: 8px 16px; font-size: 0.9em; }
        .create-game-form {
            background: rgba(255,255,255,0.1);
            border-radius: 12px; padding: 20px; margin-bottom: 20px;
        }
        .create-game-form h3 { margin-bottom: 15px; }
        .create-game-form .form-row { display: flex; gap: 10px; }
        .create-game-form input { flex: 1; }
        .create-game-form .btn { width: auto; }
        
        /* Game Section */
        .game-section { display: none; }
        .game-section.active { display: flex; gap: 40px; flex-wrap: wrap; justify-content: center; }
        .board-container { display: flex; flex-direction: column; align-items: center; }
        .turn-indicator {
            font-size: 1.3em; margin-bottom: 15px; padding: 10px 25px;
            background: rgba(255,255,255,0.1); border-radius: 8px;
        }
        .turn-indicator.white-turn { color: #fff; border: 2px solid #fff; }
        .turn-indicator.black-turn { color: #333; background: #f0f0f0; }
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 65px);
            grid-template-rows: repeat(8, 65px);
            border: 4px solid #8b4513;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            border-radius: 4px;
        }
        .square {
            width: 65px; height: 65px;
            display: flex; justify-content: center; align-items: center;
            font-size: 48px; cursor: pointer;
            transition: all 0.15s; position: relative;
            user-select: none;
        }
        .square.light { background: #f0d9b5; }
        .square.dark { background: #b58863; }
        .square:hover { filter: brightness(1.1); }
        .square.selected { background: #7fc97f !important; box-shadow: inset 0 0 10px rgba(0,100,0,0.5); }
        .square.valid-move::after {
            content: ''; position: absolute;
            width: 20px; height: 20px;
            background: rgba(0, 128, 0, 0.5);
            border-radius: 50%;
        }
        .square.valid-capture::after {
            content: ''; position: absolute;
            width: 100%; height: 100%;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 0;
        }
        .square.last-move { box-shadow: inset 0 0 15px rgba(255, 255, 0, 0.6); }
        .square.in-check { animation: pulse-check 1s infinite; }
        @keyframes pulse-check {
            0%, 100% { background: rgba(255, 0, 0, 0.5); }
            50% { background: rgba(255, 0, 0, 0.8); }
        }
        .piece { text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .board-labels { display: flex; justify-content: space-around; width: 520px; margin-top: 5px; }
        .board-labels span { width: 65px; text-align: center; color: #ccc; font-weight: bold; }
        .rank-labels {
            display: flex; flex-direction: column; justify-content: space-around;
            height: 520px; margin-right: 5px;
        }
        .rank-labels span { height: 65px; display: flex; align-items: center; color: #ccc; font-weight: bold; }
        .board-wrapper { display: flex; }
        
        /* Game Info Panel */
        .game-info {
            background: rgba(255,255,255,0.1);
            border-radius: 12px; padding: 20px; min-width: 280px;
        }
        .game-info h3 { margin-bottom: 15px; border-bottom: 2px solid rgba(255,255,255,0.2); padding-bottom: 10px; }
        .player-info { margin-bottom: 20px; }
        .player-info .player {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; margin-bottom: 8px;
        }
        .player-info .player.active { border: 2px solid #7fc97f; }
        .captured-pieces { margin-bottom: 20px; }
        .captured-pieces h4 { font-size: 0.9em; color: #ccc; margin-bottom: 8px; }
        .captured-list {
            min-height: 35px; background: rgba(0,0,0,0.2);
            border-radius: 6px; padding: 5px; font-size: 28px;
        }
        .game-controls { display: flex; flex-direction: column; gap: 10px; }
        .game-controls .btn { width: 100%; }
        .status-message {
            padding: 15px; margin-top: 15px;
            background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center;
        }
        .status-message.check { background: rgba(255, 165, 0, 0.3); border: 2px solid orange; }
        .status-message.checkmate { background: rgba(255, 0, 0, 0.3); border: 2px solid red; }
        .status-message.victory { background: rgba(0, 255, 0, 0.3); border: 2px solid green; }
        
        /* Promotion Modal */
        .modal {
            display: none; position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center; align-items: center; z-index: 1000;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: #f0d9b5; padding: 20px; border-radius: 12px;
        }
        .modal-content h3 { color: #333; margin-bottom: 15px; text-align: center; }
        .promotion-choices { display: flex; gap: 10px; }
        .promotion-choice {
            width: 70px; height: 70px; font-size: 50px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; background: #b58863; border-radius: 8px;
            transition: all 0.2s; border: none;
        }
        .promotion-choice:hover { transform: scale(1.1); box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
        
        /* Notifications */
        .notification {
            position: fixed; top: 20px; right: 20px;
            padding: 15px 25px; border-radius: 8px;
            background: rgba(0,0,0,0.8); color: #fff;
            transform: translateX(400px); transition: transform 0.3s;
            z-index: 1001;
        }
        .notification.show { transform: translateX(0); }
        .notification.error { border-left: 4px solid #f5576c; }
        .notification.success { border-left: 4px solid #38ef7d; }
        .notification.info { border-left: 4px solid #667eea; }

        /* Loading */
        .loading { text-align: center; padding: 40px; color: #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <h1>♔ Chess Game ♚</h1>
        
        <!-- Auth Section -->
        <div class="auth-section" id="authSection">
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="showAuthTab('login')">Login</button>
                <button class="auth-tab" onclick="showAuthTab('register')">Register</button>
            </div>
            <form class="auth-form active" id="loginForm" onsubmit="login(event)">
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="loginUsername" required>
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button type="submit" class="btn btn-primary">Login</button>
            </form>
            <form class="auth-form" id="registerForm" onsubmit="register(event)">
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="regUsername" required>
                </div>
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="regEmail" required>
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="regPassword" required>
                </div>
                <button type="submit" class="btn btn-primary">Register</button>
            </form>
        </div>
        
        <!-- Lobby Section -->
        <div class="lobby-section" id="lobbySection">
            <div class="user-info">
                <span>Welcome, <strong id="currentUser"></strong>!</span>
                <button class="btn btn-secondary" onclick="logout()" style="width:auto;padding:8px 20px;">Logout</button>
            </div>
            <div class="create-game-form">
                <h3>Create New Game</h3>
                <div class="form-row">
                    <input type="text" id="newGameName" placeholder="Game name...">
                    <button class="btn btn-success" onclick="createGame()">Create Game</button>
                </div>
            </div>
            <h3 style="margin-bottom:15px;">Available Games</h3>
            <div class="games-container" id="gamesContainer">
                <div class="loading">Loading games...</div>
            </div>
            <button class="btn btn-primary" onclick="refreshGames()" style="width:auto;padding:10px 30px;">
                Refresh Games
            </button>
        </div>
        
        <!-- Game Section -->
        <div class="game-section" id="gameSection">
            <div class="board-container">
                <div class="turn-indicator white-turn" id="turnIndicator">White's Turn</div>
                <div class="board-wrapper">
                    <div class="rank-labels">
                        <span>8</span><span>7</span><span>6</span><span>5</span>
                        <span>4</span><span>3</span><span>2</span><span>1</span>
                    </div>
                    <div>
                        <div class="chessboard" id="chessboard"></div>
                        <div class="board-labels">
                            <span>a</span><span>b</span><span>c</span><span>d</span>
                            <span>e</span><span>f</span><span>g</span><span>h</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="game-info">
                <h3 id="gameTitle">Game</h3>
                <div class="player-info">
                    <div class="player" id="whitePlayer">
                        <span>⬜ White</span>
                        <span id="whiteUsername">-</span>
                    </div>
                    <div class="player" id="blackPlayer">
                        <span>⬛ Black</span>
                        <span id="blackUsername">-</span>
                    </div>
                </div>
                <div class="captured-pieces">
                    <h4>Captured by White:</h4>
                    <div class="captured-list" id="capturedByWhite"></div>
                </div>
                <div class="captured-pieces">
                    <h4>Captured by Black:</h4>
                    <div class="captured-list" id="capturedByBlack"></div>
                </div>
                <div class="game-controls">
                    <button class="btn btn-primary" onclick="leaveGame()">Leave Game</button>
                </div>
                <div class="status-message" id="statusMessage" style="display:none;"></div>
            </div>
        </div>
    </div>
    
    <!-- Promotion Modal -->
    <div class="modal" id="promotionModal">
        <div class="modal-content">
            <h3>Choose Promotion</h3>
            <div class="promotion-choices" id="promotionChoices"></div>
        </div>
    </div>
    
    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // Configuration
        const API_BASE = 'http://localhost:8080';
        
        // State
        let authToken = null;
        let currentUsername = null;
        let currentGameId = null;
        let currentGame = null;
        let playerColor = null;
        let selectedSquare = null;
        let validMoves = [];
        let ws = null;
        
        // Piece symbols
        const PIECES = {
            WHITE: { KING: '♔', QUEEN: '♕', ROOK: '♖', BISHOP: '♗', KNIGHT: '♘', PAWN: '♙' },
            BLACK: { KING: '♚', QUEEN: '♛', ROOK: '♜', BISHOP: '♝', KNIGHT: '♞', PAWN: '♟' }
        };

        // ============ AUTH ============
        function showAuthTab(tab) {
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
            document.querySelector(`.auth-tab:${tab === 'login' ? 'first' : 'last'}-child`).classList.add('active');
            document.getElementById(tab === 'login' ? 'loginForm' : 'registerForm').classList.add('active');
        }

        async function login(e) {
            e.preventDefault();
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;
            
            try {
                const res = await fetch(`${API_BASE}/session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                const data = await res.json();
                if (res.ok) {
                    authToken = data.authToken;
                    currentUsername = data.username;
                    showLobby();
                    notify('Logged in successfully!', 'success');
                } else {
                    notify(data.message || 'Login failed', 'error');
                }
            } catch (err) {
                notify('Connection error. Is the server running?', 'error');
            }
        }

        async function register(e) {
            e.preventDefault();
            const username = document.getElementById('regUsername').value;
            const email = document.getElementById('regEmail').value;
            const password = document.getElementById('regPassword').value;
            
            try {
                const res = await fetch(`${API_BASE}/user`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password, email })
                });
                const data = await res.json();
                if (res.ok) {
                    authToken = data.authToken;
                    currentUsername = data.username;
                    showLobby();
                    notify('Registered successfully!', 'success');
                } else {
                    notify(data.message || 'Registration failed', 'error');
                }
            } catch (err) {
                notify('Connection error. Is the server running?', 'error');
            }
        }

        async function logout() {
            try {
                await fetch(`${API_BASE}/session`, {
                    method: 'DELETE',
                    headers: { 'Authorization': authToken }
                });
            } catch (err) {}
            authToken = null;
            currentUsername = null;
            showAuth();
            notify('Logged out', 'info');
        }

        // ============ NAVIGATION ============
        function showAuth() {
            document.getElementById('authSection').style.display = 'block';
            document.getElementById('lobbySection').classList.remove('active');
            document.getElementById('gameSection').classList.remove('active');
        }

        function showLobby() {
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('lobbySection').classList.add('active');
            document.getElementById('gameSection').classList.remove('active');
            document.getElementById('currentUser').textContent = currentUsername;
            refreshGames();
        }

        function showGame() {
            document.getElementById('authSection').style.display = 'none';
            document.getElementById('lobbySection').classList.remove('active');
            document.getElementById('gameSection').classList.add('active');
        }

        // ============ LOBBY ============
        async function refreshGames() {
            const container = document.getElementById('gamesContainer');
            container.innerHTML = '<div class="loading">Loading games...</div>';
            
            try {
                const res = await fetch(`${API_BASE}/game`, {
                    headers: { 'Authorization': authToken }
                });
                const data = await res.json();
                
                if (!data.games || data.games.length === 0) {
                    container.innerHTML = '<div class="loading">No games available. Create one!</div>';
                    return;
                }
                
                container.innerHTML = data.games.map(game => `
                    <div class="game-card">
                        <h3>${escapeHtml(game.gameName)}</h3>
                        <div class="players">
                            ⬜ White: ${game.whiteUsername || '<em>Open</em>'}<br>
                            ⬛ Black: ${game.blackUsername || '<em>Open</em>'}
                        </div>
                        <div class="actions">
                            ${!game.whiteUsername ? `<button class="btn btn-success" onclick="joinGame(${game.gameID}, 'WHITE')">Join White</button>` : ''}
                            ${!game.blackUsername ? `<button class="btn btn-success" onclick="joinGame(${game.gameID}, 'BLACK')">Join Black</button>` : ''}
                            <button class="btn btn-primary" onclick="observeGame(${game.gameID})">Watch</button>
                        </div>
                    </div>
                `).join('');
            } catch (err) {
                container.innerHTML = '<div class="loading">Error loading games</div>';
                notify('Failed to load games', 'error');
            }
        }

        async function createGame() {
            const name = document.getElementById('newGameName').value.trim();
            if (!name) {
                notify('Please enter a game name', 'error');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/game`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': authToken
                    },
                    body: JSON.stringify({ gameName: name })
                });
                const data = await res.json();
                if (res.ok) {
                    document.getElementById('newGameName').value = '';
                    notify('Game created!', 'success');
                    refreshGames();
                } else {
                    notify(data.message || 'Failed to create game', 'error');
                }
            } catch (err) {
                notify('Failed to create game', 'error');
            }
        }

        async function joinGame(gameId, color) {
            try {
                const res = await fetch(`${API_BASE}/game`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': authToken
                    },
                    body: JSON.stringify({ gameID: gameId, playerColor: color })
                });
                
                if (res.ok) {
                    currentGameId = gameId;
                    playerColor = color;
                    await loadGame(gameId);
                    connectWebSocket(gameId);
                    showGame();
                    notify(`Joined as ${color}!`, 'success');
                } else {
                    const data = await res.json();
                    notify(data.message || 'Failed to join', 'error');
                }
            } catch (err) {
                notify('Failed to join game', 'error');
            }
        }

        async function observeGame(gameId) {
            currentGameId = gameId;
            playerColor = null;
            await loadGame(gameId);
            connectWebSocket(gameId);
            showGame();
            notify('Observing game', 'info');
        }

        async function loadGame(gameId) {
            try {
                const res = await fetch(`${API_BASE}/game/${gameId}`, {
                    headers: { 'Authorization': authToken }
                });
                const data = await res.json();
                currentGame = data;
                document.getElementById('gameTitle').textContent = data.gameName || 'Chess Game';
                document.getElementById('whiteUsername').textContent = data.whiteUsername || 'Waiting...';
                document.getElementById('blackUsername').textContent = data.blackUsername || 'Waiting...';
                renderBoard();
            } catch (err) {
                notify('Failed to load game', 'error');
            }
        }

        function leaveGame() {
            if (ws) ws.close();
            currentGameId = null;
            currentGame = null;
            playerColor = null;
            selectedSquare = null;
            validMoves = [];
            showLobby();
        }

        // ============ WEBSOCKET ============
        function connectWebSocket(gameId) {
            if (ws) ws.close();
            
            const wsUrl = `ws://localhost:8080/ws`;
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                // Send connect command
                ws.send(JSON.stringify({
                    commandType: 'CONNECT',
                    authToken: authToken,
                    gameID: gameId
                }));
            };
            
            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    handleServerMessage(msg);
                } catch (err) {
                    console.error('WebSocket message error:', err);
                }
            };
            
            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };
            
            ws.onclose = () => {
                console.log('WebSocket closed');
            };
        }

        function handleServerMessage(msg) {
            switch (msg.serverMessageType) {
                case 'LOAD_GAME':
                    if (msg.game) {
                        currentGame.game = msg.game;
                        renderBoard();
                    }
                    break;
                case 'NOTIFICATION':
                    notify(msg.message, 'info');
                    break;
                case 'ERROR':
                    notify(msg.errorMessage, 'error');
                    break;
            }
        }

        // ============ CHESS BOARD ============
        function renderBoard() {
            const board = document.getElementById('chessboard');
            board.innerHTML = '';
            
            const gameBoard = parseBoard(currentGame?.game?.board);
            const turn = currentGame?.game?.teamTurn || 'WHITE';
            
            // Update turn indicator
            const indicator = document.getElementById('turnIndicator');
            indicator.textContent = `${turn === 'WHITE' ? 'White' : 'Black'}'s Turn`;
            indicator.className = `turn-indicator ${turn.toLowerCase()}-turn`;
            
            // Update active player highlight
            document.getElementById('whitePlayer').classList.toggle('active', turn === 'WHITE');
            document.getElementById('blackPlayer').classList.toggle('active', turn === 'BLACK');
            
            for (let row = 8; row >= 1; row--) {
                for (let col = 1; col <= 8; col++) {
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Check if selected
                    if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // Check if valid move
                    const isValidMove = validMoves.some(m => m.row === row && m.col === col);
                    if (isValidMove) {
                        const piece = gameBoard[row]?.[col];
                        square.classList.add(piece ? 'valid-capture' : 'valid-move');
                    }
                    
                    // Add piece
                    const piece = gameBoard[row]?.[col];
                    if (piece) {
                        square.innerHTML = `<span class="piece">${getPieceSymbol(piece)}</span>`;
                    }
                    
                    square.onclick = () => handleSquareClick(row, col);
                    board.appendChild(square);
                }
            }
            
            updateGameStatus();
        }

        function parseBoard(boardData) {
            const board = {};
            if (!boardData?.board) return board;
            
            // Handle the Java serialization format
            for (const [key, piece] of Object.entries(boardData.board)) {
                // Parse keys like "ChessPosition{row=2, col=1}" or "2,1"
                let row, col;
                if (key.includes('row=')) {
                    const rowMatch = key.match(/row=(\d+)/);
                    const colMatch = key.match(/col=(\d+)/);
                    if (rowMatch && colMatch) {
                        row = parseInt(rowMatch[1]);
                        col = parseInt(colMatch[1]);
                    }
                } else if (key.includes(',')) {
                    [row, col] = key.split(',').map(Number);
                }
                
                if (row && col) {
                    if (!board[row]) board[row] = {};
                    board[row][col] = piece;
                }
            }
            return board;
        }

        function getPieceSymbol(piece) {
            if (!piece) return '';
            const color = piece.pieceColor || piece.teamColor || 'WHITE';
            const type = piece.type || piece.pieceType || 'PAWN';
            return PIECES[color.toUpperCase()]?.[type.toUpperCase()] || '';
        }

        function handleSquareClick(row, col) {
            // If observing, do nothing
            if (!playerColor) return;
            
            // Check if it's our turn
            const turn = currentGame?.game?.teamTurn || 'WHITE';
            if (turn !== playerColor) {
                notify("It's not your turn!", 'error');
                return;
            }
            
            const gameBoard = parseBoard(currentGame?.game?.board);
            const clickedPiece = gameBoard[row]?.[col];
            
            if (selectedSquare) {
                // Check if clicking on valid move
                const isValidMove = validMoves.some(m => m.row === row && m.col === col);
                if (isValidMove) {
                    makeMove(selectedSquare, { row, col });
                } else if (clickedPiece && (clickedPiece.pieceColor || clickedPiece.teamColor)?.toUpperCase() === playerColor) {
                    // Select different piece
                    selectPiece(row, col, gameBoard);
                } else {
                    // Deselect
                    selectedSquare = null;
                    validMoves = [];
                    renderBoard();
                }
            } else if (clickedPiece) {
                const pieceColor = (clickedPiece.pieceColor || clickedPiece.teamColor)?.toUpperCase();
                if (pieceColor === playerColor) {
                    selectPiece(row, col, gameBoard);
                }
            }
        }

        function selectPiece(row, col, gameBoard) {
            selectedSquare = { row, col };
            validMoves = calculateValidMoves(row, col, gameBoard);
            renderBoard();
        }

        function calculateValidMoves(row, col, gameBoard) {
            // Simplified valid move calculation
            // The server will validate the actual move
            const moves = [];
            const piece = gameBoard[row]?.[col];
            if (!piece) return moves;
            
            const color = (piece.pieceColor || piece.teamColor)?.toUpperCase();
            const type = (piece.type || piece.pieceType)?.toUpperCase();
            
            // For simplicity, show all theoretically possible squares
            // Server will reject invalid moves
            for (let r = 1; r <= 8; r++) {
                for (let c = 1; c <= 8; c++) {
                    if (r === row && c === col) continue;
                    const target = gameBoard[r]?.[c];
                    const targetColor = target ? (target.pieceColor || target.teamColor)?.toUpperCase() : null;
                    if (targetColor !== color) {
                        // Basic move validation based on piece type
                        if (isValidMoveForPiece(type, row, col, r, c, color, gameBoard)) {
                            moves.push({ row: r, col: c });
                        }
                    }
                }
            }
            return moves;
        }

        function isValidMoveForPiece(type, fromRow, fromCol, toRow, toCol, color, board) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);
            const direction = color === 'WHITE' ? 1 : -1;
            
            switch (type) {
                case 'PAWN':
                    // Forward move
                    if (fromCol === toCol && !board[toRow]?.[toCol]) {
                        if (toRow - fromRow === direction) return true;
                        if ((fromRow === 2 && color === 'WHITE' || fromRow === 7 && color === 'BLACK') 
                            && toRow - fromRow === 2 * direction && !board[fromRow + direction]?.[fromCol]) return true;
                    }
                    // Capture
                    if (colDiff === 1 && toRow - fromRow === direction && board[toRow]?.[toCol]) return true;
                    return false;
                case 'KNIGHT':
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                case 'BISHOP':
                    return rowDiff === colDiff && isPathClear(fromRow, fromCol, toRow, toCol, board);
                case 'ROOK':
                    return (rowDiff === 0 || colDiff === 0) && isPathClear(fromRow, fromCol, toRow, toCol, board);
                case 'QUEEN':
                    return (rowDiff === colDiff || rowDiff === 0 || colDiff === 0) && isPathClear(fromRow, fromCol, toRow, toCol, board);
                case 'KING':
                    return rowDiff <= 1 && colDiff <= 1;
                default:
                    return false;
            }
        }

        function isPathClear(fromRow, fromCol, toRow, toCol, board) {
            const rowStep = Math.sign(toRow - fromRow);
            const colStep = Math.sign(toCol - fromCol);
            let r = fromRow + rowStep;
            let c = fromCol + colStep;
            while (r !== toRow || c !== toCol) {
                if (board[r]?.[c]) return false;
                r += rowStep;
                c += colStep;
            }
            return true;
        }

        function makeMove(from, to) {
            // Check for pawn promotion
            const gameBoard = parseBoard(currentGame?.game?.board);
            const piece = gameBoard[from.row]?.[from.col];
            const type = (piece?.type || piece?.pieceType)?.toUpperCase();
            
            if (type === 'PAWN' && (to.row === 8 || to.row === 1)) {
                showPromotionModal(from, to);
                return;
            }
            
            sendMove(from, to, null);
        }

        function showPromotionModal(from, to) {
            const modal = document.getElementById('promotionModal');
            const choices = document.getElementById('promotionChoices');
            const color = playerColor;
            
            choices.innerHTML = ['QUEEN', 'ROOK', 'BISHOP', 'KNIGHT'].map(type => `
                <button class="promotion-choice" onclick="selectPromotion('${type}', ${from.row}, ${from.col}, ${to.row}, ${to.col})">
                    ${PIECES[color][type]}
                </button>
            `).join('');
            
            modal.classList.add('active');
        }

        function selectPromotion(type, fromRow, fromCol, toRow, toCol) {
            document.getElementById('promotionModal').classList.remove('active');
            sendMove({ row: fromRow, col: fromCol }, { row: toRow, col: toCol }, type);
        }

        function sendMove(from, to, promotion) {
            selectedSquare = null;
            validMoves = [];
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    commandType: 'MAKE_MOVE',
                    authToken: authToken,
                    gameID: currentGameId,
                    move: {
                        startPosition: { row: from.row, col: from.col },
                        endPosition: { row: to.row, col: to.col },
                        promotionPiece: promotion
                    }
                }));
            }
            
            // Optimistic update - move piece locally
            const gameBoard = parseBoard(currentGame?.game?.board);
            const piece = gameBoard[from.row]?.[from.col];
            if (piece) {
                // Update local state
                if (!currentGame.game.board.board) currentGame.game.board.board = {};
                
                // Remove from old position
                for (const key of Object.keys(currentGame.game.board.board)) {
                    if (key.includes(`row=${from.row}`) && key.includes(`col=${from.col}`)) {
                        delete currentGame.game.board.board[key];
                        break;
                    }
                }
                
                // Add to new position
                const newKey = `ChessPosition{row=${to.row}, col=${to.col}}`;
                if (promotion) {
                    piece.type = promotion;
                    piece.pieceType = promotion;
                }
                currentGame.game.board.board[newKey] = piece;
                
                // Toggle turn
                currentGame.game.teamTurn = currentGame.game.teamTurn === 'WHITE' ? 'BLACK' : 'WHITE';
                
                renderBoard();
            }
        }

        function updateGameStatus() {
            const status = document.getElementById('statusMessage');
            const isGameOver = currentGame?.game?.isGameOver;
            
            if (isGameOver) {
                status.textContent = 'Game Over!';
                status.className = 'status-message checkmate';
                status.style.display = 'block';
            } else {
                status.style.display = 'none';
            }
        }

        // ============ UTILITIES ============
        function notify(message, type = 'info') {
            const notif = document.getElementById('notification');
            notif.textContent = message;
            notif.className = `notification ${type} show`;
            setTimeout(() => notif.classList.remove('show'), 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize
        showAuth();
    </script>
</body>
</html>
